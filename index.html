<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Modular Labyrinth Runner</title>
<style>
  :root {
    --bg:#08121a; --panel:#071824; --accent:#06b6d4; --muted:#9aa8b6; --danger:#ff6b6b;
  }
  *{box-sizing:border-box}
  body{margin:0;min-height:100vh;background:linear-gradient(180deg,#031018 0%, #071824 100%);color:#dbeafe;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;padding:18px;display:flex;align-items:flex-start;gap:18px}
  .ui{width:360px;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.04);padding:14px;border-radius:12px;box-shadow:0 6px 24px rgba(2,6,23,0.6)}
  h1{font-size:18px;margin:0 0 10px 0}
  label{font-size:13px;color:var(--muted);display:block;margin-top:8px}
  select,input[type=range]{width:100%;margin-top:6px}
  button{background:var(--accent);color:#042029;padding:8px 10px;border-radius:8px;border:0;cursor:pointer;font-weight:600}
  .small{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted);padding:6px 8px;border-radius:8px;cursor:pointer}
  .status{margin-top:12px;font-size:13px;color:var(--muted)}
  .kbd{display:inline-block;background:#04121a;padding:3px 8px;border-radius:6px;border:1px solid rgba(255,255,255,0.02);font-weight:600;margin-left:6px}
  .footer{font-size:12px;color:var(--muted);margin-top:12px}
  /* canvas panel */
  .panel{flex:1;display:flex;flex-direction:column;gap:10px;align-items:center}
  .canvas-wrap{background:linear-gradient(180deg,#041222,#051827);padding:12px;border-radius:12px;border:1px solid rgba(255,255,255,0.03);box-shadow:0 8px 30px rgba(2,6,23,0.6)}
  canvas{display:block;border-radius:8px;background:#00121a}
  .row{display:flex;gap:8px;align-items:center;margin-top:6px}
  .hint{color:var(--muted);font-size:13px;margin-top:8px}
  .pill{display:inline-block;padding:6px 10px;border-radius:999px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03);font-weight:600}
</style>
</head>
<body>

  <aside class="ui" aria-label="Game controls">
    <h1>Labyrinth Runner — Modular Engine</h1>

    <label>Difficulty</label>
    <select id="difficulty">
      <!-- populated by JS -->
    </select>

    <label>Start / Stop</label>
    <div style="display:flex;gap:8px">
      <button id="startBtn">Start Game</button>
      <button id="stopBtn" class="small">Stop</button>
      <button id="resetBtn" class="small">Reset</button>
    </div>

    <label>Quick actions</label>
    <div style="display:flex;gap:8px;margin-top:6px">
      <button id="spawnKeys" class="small">Spawn Keys (debug)</button>
      <button id="toggleFog" class="small">Toggle Fog</button>
    </div>

    <div class="status">
      <div>Timer: <span id="timer">—</span></div>
      <div>Keys: <span id="keysCollected">0</span> / <span id="keysRequired">0</span></div>
      <div>Mode: <span id="modeLabel">—</span></div>
      <div>Vision: <span id="visionLabel">∞</span></div>
    </div>

    <div class="footer">
      Controls: arrow keys / WASD to move. Press <span class="kbd">Space</span> to interact at objects.<br>
      To add or tweak difficulties: edit the <code>difficulties</code> object in the JS. No logic changes needed.
    </div>
  </aside>

  <main class="panel">
    <div class="canvas-wrap" role="region" aria-label="Maze canvas">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
        <div class="pill" id="objective">Objective: Reach Exit</div>
        <div class="pill" id="message">Status: Idle</div>
      </div>
      <canvas id="gameCanvas" width="720" height="720" tabindex="0"></canvas>
      <div class="row">
        <div id="progress" class="hint">Maze: —</div>
        <div style="flex:1"></div>
        <div class="hint">Shifting walls are automatic per difficulty</div>
      </div>
    </div>
  </main>

<script>
/* ===========================
   Modular Labyrinth Runner
   - Single-file engine
   - Edit only `difficulties` to add modes
   =========================== */

(() => {
  // --- Difficulty settings (only edit here to add modes) ---
  const difficulties = {
    easy:    { label:'Easy',       size:10, time:60,  shiftInterval:0, shiftChance:0,   keysNeeded:0,  minotaur:false, visionRadius: Infinity },
    medium:  { label:'Medium',     size:15, time:45,  shiftInterval:5, shiftChance:0.2, keysNeeded:0,  minotaur:false, visionRadius: 6 },
    hard:    { label:'Hard',       size:20, time:30,  shiftInterval:3, shiftChance:1,   keysNeeded:3,  minotaur:false, visionRadius: 5 },
    hardcore:{ label:'Hardcore',   size:20, time:15,  shiftInterval:1, shiftChance:1,   keysNeeded:2,  minotaur:true,  visionRadius: 4 }
  };

  // UI bindings
  const difficultySelect = document.getElementById('difficulty');
  const startBtn = document.getElementById('startBtn');
  const stopBtn = document.getElementById('stopBtn');
  const resetBtn = document.getElementById('resetBtn');
  const spawnKeysBtn = document.getElementById('spawnKeys');
  const toggleFogBtn = document.getElementById('toggleFog');

  const timerEl = document.getElementById('timer');
  const keysCollectedEl = document.getElementById('keysCollected');
  const keysRequiredEl = document.getElementById('keysRequired');
  const modeLabel = document.getElementById('modeLabel');
  const visionLabel = document.getElementById('visionLabel');
  const progressEl = document.getElementById('progress');
  const objectiveEl = document.getElementById('objective');
  const messageEl = document.getElementById('message');

  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  // Populate difficulty dropdown
  Object.keys(difficulties).forEach(key => {
    const opt = document.createElement('option');
    opt.value = key;
    opt.textContent = difficulties[key].label;
    difficultySelect.appendChild(opt);
  });

  // State
  let currentSettings = null;
  let maze = null; // cells grid
  let cols = 0, rows = 0;
  let cellSize = 0;
  let player = null;
  let exitCell = null;
  let keys = []; // array of positions
  let keysCollected = 0;
  let timer = 0;
  let timerInterval = null;
  let shiftTimer = null;
  let running = false;
  let fogEnabled = false;
  let minotaur = null;
  let shiftTick = 0;

  // --- Maze generator (recursive backtracker) ---
  function makeMaze(n) {
    cols = n; rows = n;
    // grid of cells, each cell has walls: [N,E,S,W] true=wall exists
    const grid = new Array(cols);
    for(let x=0;x<cols;x++){
      grid[x]=new Array(rows);
      for(let y=0;y<rows;y++){
        grid[x][y] = { x, y, walls: [true,true,true,true], visited:false };
      }
    }

    // helpers
    function neighbors(c){
      const list = [];
      const {x,y} = c;
      if(y>0) list.push(grid[x][y-1]);       // N
      if(x<cols-1) list.push(grid[x+1][y]);  // E
      if(y<rows-1) list.push(grid[x][y+1]);  // S
      if(x>0) list.push(grid[x-1][y]);       // W
      return list.filter(n=>!n.visited);
    }

    // remove wall between
    function removeWall(a,b){
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      if(dx === 1){ a.walls[1]=false; b.walls[3]=false; } // E/W
      else if(dx === -1){ a.walls[3]=false; b.walls[1]=false; }
      else if(dy === 1){ a.walls[2]=false; b.walls[0]=false; } // S/N
      else if(dy === -1){ a.walls[0]=false; b.walls[2]=false; }
    }

    // iterative stack
    const stack = [];
    const start = grid[0][0];
    start.visited = true;
    stack.push(start);

    while(stack.length){
      const current = stack[stack.length-1];
      const n = neighbors(current);
      if(n.length){
        const next = n[Math.floor(Math.random()*n.length)];
        removeWall(current,next);
        next.visited = true;
        stack.push(next);
      } else {
        stack.pop();
      }
    }
    // mark visited back to false for future algorithms
    for(let x=0;x<cols;x++) for(let y=0;y<rows;y++) grid[x][y].visited = false;
    return grid;
  }

  // --- Utilities ---
  function cellToPixel(c){ return { px: Math.round(c.x * cellSize), py: Math.round(c.y * cellSize) }; }
  function inCellCenter(px, py){ return { cx: Math.floor(px / cellSize), cy: Math.floor(py / cellSize) }; }

  // --- Rendering ---
  function drawMaze() {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    const pad = 6;
    const area = Math.min(canvas.width, canvas.height) - pad*2;
    cellSize = Math.floor(area / Math.max(cols, rows));
    const originX = Math.floor((canvas.width - cols*cellSize)/2);
    const originY = Math.floor((canvas.height - rows*cellSize)/2);

    // store for other functions
    const topLeft = { originX, originY };

    // background
    ctx.fillStyle = '#00161a';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // cells
    ctx.strokeStyle = '#0f1724';
    ctx.lineWidth = Math.max(2, Math.floor(cellSize*0.08));

    for(let x=0;x<cols;x++){
      for(let y=0;y<rows;y++){
        const c = maze[x][y];
        const px = originX + x*cellSize;
        const py = originY + y*cellSize;

        // floor
        ctx.fillStyle = '#02252b';
        ctx.fillRect(px+1, py+1, cellSize-2, cellSize-2);

        ctx.strokeStyle = '#08333a';
        // walls
        ctx.beginPath();
        if(c.walls[0]) { ctx.moveTo(px,py); ctx.lineTo(px+cellSize,py); } // N
        if(c.walls[1]) { ctx.moveTo(px+cellSize,py); ctx.lineTo(px+cellSize,py+cellSize); } // E
        if(c.walls[2]) { ctx.moveTo(px+cellSize,py+cellSize); ctx.lineTo(px,py+cellSize); } // S
        if(c.walls[3]) { ctx.moveTo(px,py+cellSize); ctx.lineTo(px,py); } // W
        ctx.stroke();
      }
    }

    // draw keys
    keys.forEach(k => {
      const px = originX + k.x*cellSize + cellSize/2;
      const py = originY + k.y*cellSize + cellSize/2;
      ctx.fillStyle = '#ffd166';
      ctx.beginPath();
      ctx.arc(px, py, Math.max(4,cellSize*0.14), 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#b37f00';
      ctx.fillRect(px-2, py-1, 4, 2);
    });

    // exit door
    if(exitCell){
      const px = originX + exitCell.x*cellSize;
      const py = originY + exitCell.y*cellSize;
      ctx.fillStyle = '#34d399';
      ctx.fillRect(px + cellSize*0.2, py + cellSize*0.2, cellSize*0.6, cellSize*0.6);
    }

    // draw player
    {
      const px = originX + player.x*cellSize + cellSize*0.12;
      const py = originY + player.y*cellSize + cellSize*0.12;
      ctx.fillStyle = '#60a5fa';
      ctx.fillRect(px, py, cellSize*0.76, cellSize*0.76);
    }

    // draw minotaur if exists
    if(minotaur){
      const px = originX + minotaur.x*cellSize + cellSize*0.2;
      const py = originY + minotaur.y*cellSize + cellSize*0.2;
      ctx.fillStyle = '#ff6b6b';
      ctx.fillRect(px, py, cellSize*0.6, cellSize*0.6);
    }

    // fog of war for finite vision
    if(fogEnabled && currentSettings.visionRadius !== Infinity){
      const vis = currentSettings.visionRadius;
      const grad = ctx.createRadialGradient(
        originX + (player.x+0.5)*cellSize, originY + (player.y+0.5)*cellSize, Math.max(5, cellSize*0.5),
        originX + (player.x+0.5)*cellSize, originY + (player.y+0.5)*cellSize, (vis+0.5)*cellSize
      );
      grad.addColorStop(0, 'rgba(0,0,0,0)');
      grad.addColorStop(0.7, 'rgba(0,0,0,0.4)');
      grad.addColorStop(1, 'rgba(0,0,0,0.95)');
      ctx.fillStyle = grad;
      ctx.fillRect(0,0,canvas.width,canvas.height);
    }

    // small overlays
    progressEl.textContent = `Maze: ${cols}×${rows}  cellSize: ${cellSize}px`;
    return topLeft;
  }

  // --- Collision & movement helpers ---
  function canMove(from, dir){
    // dir: 0=N,1=E,2=S,3=W
    return !maze[from.x][from.y].walls[dir];
  }

  function movePlayer(dir){
    if(!running) return;
    if(!canMove(player,dir)) return;
    if(dir===0) player.y -=1;
    if(dir===1) player.x +=1;
    if(dir===2) player.y +=1;
    if(dir===3) player.x -=1;
    onPlayerMove();
  }

  function onPlayerMove(){
    // collect key?
    for(let i=keys.length-1;i>=0;i--){
      if(keys[i].x===player.x && keys[i].y===player.y){
        keys.splice(i,1);
        keysCollected++;
        keysCollectedEl.textContent = keysCollected;
        messageEl.textContent = 'Picked up a key!';
      }
    }
    // reached exit?
    if(exitCell && player.x===exitCell.x && player.y===exitCell.y){
      if(keysCollected >= currentSettings.keysNeeded){
        winGame();
      } else {
        messageEl.textContent = `Door locked — need ${currentSettings.keysNeeded - keysCollected} more key(s).`;
      }
    }
    // minotaur check
    if(minotaur && player.x===minotaur.x && player.y===minotaur.y){
      loseGame('Caught by the Minotaur!');
    }
    drawMaze();
  }

  // --- Key placement ---
  function placeKeys(n){
    keys = [];
    let attempts=0;
    while(keys.length < n && attempts < 1000){
      attempts++;
      const x = Math.floor(Math.random()*cols);
      const y = Math.floor(Math.random()*rows);
      // avoid spawn cell and exit
      if((x===player.x && y===player.y) || (exitCell && x===exitCell.x && y===exitCell.y)) continue;
      // avoid duplicates
      if(keys.some(k=>k.x===x && k.y===y)) continue;
      keys.push({x,y});
    }
    keysCollected = 0;
    keysCollectedEl.textContent = keysCollected;
    keysRequiredEl.textContent = currentSettings.keysNeeded;
  }

  // --- Exit placement ---
  function placeExit(){
    // place far corner from start ideally
    exitCell = { x: cols-1, y: rows-1 };
  }

  // --- Timer & shifting walls ---
  function startTimer(){
    timer = currentSettings.time;
    timerEl.textContent = formatTime(timer);
    timerInterval = setInterval(() => {
      timer -= 1;
      timerEl.textContent = formatTime(timer);
      if(timer <= 0){
        clearInterval(timerInterval);
        loseGame('Time ran out!');
      }
    }, 1000);
  }

  function stopTimer(){
    if(timerInterval) { clearInterval(timerInterval); timerInterval = null; }
  }

  function formatTime(s){
    const mm = Math.floor(s/60);
    const ss = s % 60;
    return `${mm}:${ss.toString().padStart(2,'0')}`;
  }

  // shifting walls: randomly toggle a wall between adjacent cells (must preserve connectivity)
  function startShifting(){
    if(shiftTimer) clearInterval(shiftTimer);
    if(currentSettings.shiftInterval <= 0) return;
    shiftTick = 0;
    shiftTimer = setInterval(() => {
      shiftTick++;
      // only act if chance passes
      if(Math.random() >= currentSettings.shiftChance) return;
      // choose a random cell and neighbor, toggle wall
      const x = Math.floor(Math.random()*cols);
      const y = Math.floor(Math.random()*rows);
      const c = maze[x][y];
      const dir = Math.floor(Math.random()*4);
      const nx = x + (dir===1?1:dir===3?-1:0);
      const ny = y + (dir===2?1:dir===0?-1:0);
      if(nx<0||nx>=cols||ny<0||ny>=rows) return;
      // toggle wall
      const neighbor = maze[nx][ny];
      // flip both
      c.walls[dir] = !c.walls[dir];
      neighbor.walls[(dir+2)%4] = !neighbor.walls[(dir+2)%4];
      // keep it - we could run connectivity test to avoid isolating player, but to keep code simple we allow occasional dead-ends (game balance)
      messageEl.textContent = 'Walls shifted!';
      drawMaze();
    }, currentSettings.shiftInterval * 1000);
  }

  function stopShifting(){
    if(shiftTimer){ clearInterval(shiftTimer); shiftTimer = null; }
  }

  // --- Minotaur (simple BFS path find and step) ---
  function spawnMinotaur(){
    minotaur = { x: Math.max(0, cols-1), y: 0 }; // top-right spawn
  }
  function stepMinotaur(){
    if(!minotaur) return;
    // BFS to player to find next step
    const startKey = `${minotaur.x},${minotaur.y}`;
    const goalKey = `${player.x},${player.y}`;
    const q = [ { x:minotaur.x, y:minotaur.y, path:[] } ];
    const seen = new Set([startKey]);
    while(q.length){
      const cur = q.shift();
      if(cur.x === player.x && cur.y === player.y){
        // follow path 1 step
        if(cur.path.length >= 1){
          const nxt = cur.path[0];
          minotaur.x = nxt.x; minotaur.y = nxt.y;
        }
        break;
      }
      // neighbors via available walls
      const cell = maze[cur.x][cur.y];
      const dirs = [
        {dx:0,dy:-1,dir:0},
        {dx:1,dy:0,dir:1},
        {dx:0,dy:1,dir:2},
        {dx:-1,dy:0,dir:3},
      ];
      for(const d of dirs){
        if(!cell.walls[d.dir]){
          const nx = cur.x + d.dx, ny = cur.y + d.dy;
          const key = `${nx},${ny}`;
          if(nx<0||nx>=cols||ny<0||ny>=rows) continue;
          if(seen.has(key)) continue;
          seen.add(key);
          q.push({ x:nx, y:ny, path: cur.path.concat([{x:nx,y:ny}]) });
        }
      }
    }
    // check collision with player
    if(minotaur.x === player.x && minotaur.y === player.y){
      loseGame('Caught by the Minotaur!');
    }
  }

  // --- Game start / reset / stop / win / lose ---
  function startGame(difficultyKey){
    stopGame(); // ensure clean
    currentSettings = difficulties[difficultyKey];
    modeLabel.textContent = currentSettings.label;
    visionLabel.textContent = currentSettings.visionRadius === Infinity ? '∞' : `${currentSettings.visionRadius} cells`;
    fogEnabled = currentSettings.visionRadius !== Infinity;
    // generate maze
    maze = makeMaze(currentSettings.size);
    // spawn player at 0,0
    player = { x:0, y:0 };
    // place exit
    placeExit();
    // place keys
    placeKeys(currentSettings.keysNeeded);
    // minotaur
    minotaur = currentSettings.minotaur ? { x: Math.max(0, currentSettings.size-1), y:0 } : null;
    // timer
    startTimer();
    // shifting
    startShifting();
    running = true;
    messageEl.textContent = 'Go!';
    objectiveEl.textContent = `Objective: Reach Exit${currentSettings.keysNeeded? ' (collect keys)' : ''}`;
    drawMaze();
    // step minotaur periodically if present
    if(currentSettings.minotaur){
      minotaurStepInterval = setInterval(() => {
        stepMinotaur();
        drawMaze();
      }, 400); // minotaur moves every 400ms
    }
  }

  let minotaurStepInterval = null;
  function stopGame(){
    running = false;
    stopTimer();
    stopShifting();
    if(minotaurStepInterval){ clearInterval(minotaurStepInterval); minotaurStepInterval = null; }
    messageEl.textContent = 'Stopped';
    drawMaze();
  }
  function resetGame(){
    stopGame();
    // reset variables but keep selected difficulty
    const key = difficultySelect.value;
    startGame(key);
  }

  function winGame(){
    stopGame();
    messageEl.textContent = 'You escaped! 🎉';
    alert('You win! — Reached exit in time.');
  }
  function loseGame(reason){
    stopGame();
    messageEl.textContent = reason;
    alert('Game over — ' + reason);
  }

  // --- Input handling ---
  function keyDownHandler(e){
    if(!running) return;
    const key = e.key;
    if(['ArrowUp','w','W'].includes(key)) { e.preventDefault(); movePlayer(0); }
    else if(['ArrowRight','d','D'].includes(key)) { e.preventDefault(); movePlayer(1); }
    else if(['ArrowDown','s','S'].includes(key)) { e.preventDefault(); movePlayer(2); }
    else if(['ArrowLeft','a','A'].includes(key)) { e.preventDefault(); movePlayer(3); }
    else if(key === ' '){
      e.preventDefault();
      // interact: pick up if in same cell is automatic; we can use space to attempt to open door if keys ok
      if(exitCell && player.x===exitCell.x && player.y===exitCell.y){
        if(keysCollected >= currentSettings.keysNeeded){
          winGame();
        } else {
          messageEl.textContent = `Door locked — need ${currentSettings.keysNeeded - keysCollected}`;
        }
      }
    }
  }

  // --- UI bindings ---
  startBtn.addEventListener('click', ()=>{
    const key = difficultySelect.value;
    startGame(key);
  });
  stopBtn.addEventListener('click', stopGame);
  resetBtn.addEventListener('click', resetGame);

  spawnKeysBtn.addEventListener('click', ()=>{ placeKeys( Math.max(1, currentSettings.keysNeeded || 1) ); drawMaze(); });
  toggleFogBtn.addEventListener('click', ()=>{ fogEnabled = !fogEnabled; drawMaze(); });

  // keyboard bindings for secret combo? (not needed now)
  window.addEventListener('keydown', keyDownHandler);

  // canvas focus for keypress
  canvas.addEventListener('click', ()=> canvas.focus());

  // draw initial blank
  function drawInitial(){
    ctx.fillStyle = '#00121a';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = '#6ee7b7';
    ctx.font = '20px Inter, Arial';
    ctx.fillText('Choose difficulty and press Start', 24, 40);
  }
  drawInitial();

  // set UI defaults
  difficultySelect.value = 'easy';
  modeLabel.textContent = difficulties['easy'].label;
  visionLabel.textContent = difficulties['easy'].visionRadius === Infinity ? '∞' : difficulties['easy'].visionRadius;
  keysCollectedEl.textContent = 0;
  keysRequiredEl.textContent = difficulties['easy'].keysNeeded;

  // when difficulty changes update labels
  difficultySelect.addEventListener('change', ()=>{
    const key = difficultySelect.value;
    modeLabel.textContent = difficulties[key].label;
    visionLabel.textContent = difficulties[key].visionRadius === Infinity ? '∞' : difficulties[key].visionRadius;
    keysRequiredEl.textContent = difficulties[key].keysNeeded;
    messageEl.textContent = 'Ready';
  });

  // Expose startGame function globally so adding new modes is trivial
  window.startGame = startGame;
  window.difficulties = difficulties;

  // helpful note in console
  console.log('Labyrinth Runner ready. To add modes: modify `difficulties` object. To start a mode from console: startGame("hard")');
})();
</script>
</body>
</html>
