<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Labyrinth Challenge â€” Custom Modes</title>
<style>
  :root{
    --bg:#07121a; --panel:#071824; --accent:#06b6d4; --muted:#9aa8b6; --danger:#ff6b6b;
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;background:linear-gradient(180deg,#021018 0%, #051824 100%);color:#e6f0fb;min-height:100vh;display:flex;align-items:stretch;justify-content:center;padding:18px}
  .container{width:100%;max-width:1100px;display:grid;grid-template-columns:360px 1fr;gap:18px;align-items:start}
  /* Left menu panel */
  .panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.04);padding:14px;border-radius:12px;box-shadow:0 8px 30px rgba(2,6,23,0.6)}
  h1{margin:0;font-size:18px}
  label{display:block;font-size:13px;color:var(--muted);margin-top:10px}
  .btn{background:var(--accent);color:#031827;padding:10px 12px;border-radius:8px;border:0;cursor:pointer;font-weight:700;margin-top:10px;width:100%}
  .small{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted);padding:8px;border-radius:8px;cursor:pointer;width:100%}
  .row{display:flex;gap:8px}
  .row .small{flex:1}
  .hint{font-size:13px;color:var(--muted);margin-top:8px}
  .kbd{display:inline-block;background:#031724;padding:3px 8px;border-radius:6px;border:1px solid rgba(255,255,255,0.02);font-weight:700;margin-left:6px}
  input[type=range]{width:100%}
  .field{display:flex;align-items:center;justify-content:space-between;gap:8px;margin-top:6px}
  .value{font-weight:700;color:#bfefff}
  /* Right game area */
  .game-wrap{display:flex;flex-direction:column;gap:12px}
  .canvas-wrap{background:linear-gradient(180deg,#041829,#051827);padding:12px;border-radius:12px;border:1px solid rgba(255,255,255,0.03);box-shadow:0 8px 30px rgba(2,6,23,0.6);align-self:stretch}
  canvas{display:block;border-radius:8px;background:#00121a;width:100%;height:auto;max-width:900px}
  .status{display:flex;gap:12px;align-items:center}
  .pill{padding:6px 10px;border-radius:999px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03);font-weight:700}
  .center{text-align:center}
  /* modal/gameover */
  .overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.6);z-index:200}
  .modal{background:#071824;padding:20px;border-radius:12px;border:1px solid rgba(255,255,255,0.04);width:360px;max-width:90%}
  .modal h2{margin:0 0 8px 0}
  .modal p{color:var(--muted)}
  .controls{display:flex;gap:8px;margin-top:12px}
  /* responsive */
  @media (max-width:980px){
    .container{grid-template-columns:1fr}
    .panel{order:2}
    .game-wrap{order:1}
    canvas{height:600px}
  }
</style>
</head>
<body>
  <div class="container" role="application" aria-label="Labyrinth Challenge">
    <!-- Left menu/settings -->
    <aside class="panel" aria-label="Menu & Settings">
      <h1>Labyrinth Challenge</h1>
      <div class="hint">Design your own mode using Settings, then press Play.</div>

      <label>Quick Preset</label>
      <div class="row" style="margin-top:6px">
        <button class="small" id="presetEasy">Easy</button>
        <button class="small" id="presetMedium">Medium</button>
        <button class="small" id="presetHard">Hard</button>
      </div>

      <label style="margin-top:12px">Settings</label>

      <div class="field">
        <div>Maze Size</div><div class="value" id="sizeVal">15</div>
      </div>
      <input type="range" id="size" min="5" max="30" step="1" value="15">

      <div class="field">
        <div>Time Limit (s)</div><div class="value" id="timeVal">45</div>
      </div>
      <input type="range" id="time" min="5" max="180" step="1" value="45">

      <div class="field">
        <div>Wall Shift Interval (s, 0=off)</div><div class="value" id="shiftVal">5</div>
      </div>
      <input type="range" id="shift" min="0" max="10" step="0.5" value="5">

      <div class="field">
        <div>Shift Chance (%)</div><div class="value" id="shiftChanceVal">20</div>
      </div>
      <input type="range" id="shiftChance" min="0" max="100" step="5" value="20">

      <div class="field">
        <div>Keys Required</div><div class="value" id="keysVal">0</div>
      </div>
      <input type="range" id="keys" min="0" max="6" step="1" value="0">

      <div class="field">
        <div>Vision Radius (0 = full)</div><div class="value" id="visionVal">0</div>
      </div>
      <input type="range" id="vision" min="0" max="12" step="1" value="0">

      <div class="field" style="margin-top:8px">
        <div>Minotaur</div>
        <label style="display:flex;align-items:center;gap:8px">
          <input type="checkbox" id="minotaur"> <span class="hint" style="margin-left:6px">Enable BFS Chaser</span>
        </label>
      </div>

      <div style="margin-top:12px" class="row">
        <button class="btn" id="playBtn">Play</button>
        <button class="small" id="instructionsBtn">Instructions</button>
      </div>

      <div style="margin-top:12px" class="hint">Settings are saved locally. Use presets to get started quickly.</div>
    </aside>

    <!-- Right: Game -->
    <main class="game-wrap">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div class="status">
          <div class="pill" id="modePill">Mode: Custom</div>
          <div class="pill" id="timerPill">Time: â€”</div>
          <div class="pill" id="keysPill">Keys: 0 / 0</div>
        </div>
        <div style="display:flex;gap:8px">
          <button class="small" id="menuBtn">Main Menu</button>
          <button class="small" id="restartBtn">Restart</button>
        </div>
      </div>

      <div class="canvas-wrap" role="region" aria-label="Maze area">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
          <div class="pill" id="objectivePill">Objective: Reach Exit</div>
          <div class="pill" id="statusPill">Status: Idle</div>
        </div>
        <canvas id="canvas" width="720" height="720" tabindex="0"></canvas>
        <div style="display:flex;justify-content:space-between;margin-top:8px">
          <div class="hint">Controls: arrows/WASD to move. <span class="kbd">Space</span> to interact.</div>
          <div class="hint">Click canvas to focus.</div>
        </div>
      </div>
    </main>
  </div>

  <!-- Instructions Modal -->
  <div id="instructionsModal" class="overlay" style="display:none">
    <div class="modal" role="dialog" aria-modal="true">
      <h2>How to play</h2>
      <p>Choose settings on the left and press <strong>Play</strong>. Move with arrow keys or WASD. Collect required keys (if any) and reach the exit before time runs out. Walls may shift depending on your settings. If Minotaur is enabled it will chase you using BFS pathfinding. Vision radius <em>0</em> means full visibility; otherwise your sight is limited to N cells.</p>
      <div class="controls">
        <button class="btn" id="closeInstr">Close</button>
      </div>
    </div>
  </div>

  <!-- Game Over Modal -->
  <div id="gameOverModal" class="overlay" style="display:none">
    <div class="modal" role="dialog" aria-modal="true">
      <h2 id="gameOverTitle">Game Over</h2>
      <p id="gameOverText">You lost.</p>
      <div class="controls">
        <button class="btn" id="playAgain">Play Again</button>
        <button class="small" id="backToMenu">Main Menu</button>
      </div>
    </div>
  </div>

<script>
/* ===========================
   Labyrinth Challenge â€” Modular + Menu
   - Place this whole file in one HTML and open in browser.
   - Settings persist to localStorage.
   - Minotaur uses BFS.
   =========================== */

(() => {
  // ---------- UI elements ----------
  const sizeEl = document.getElementById('size');
  const timeEl = document.getElementById('time');
  const shiftEl = document.getElementById('shift');
  const shiftChanceEl = document.getElementById('shiftChance');
  const keysEl = document.getElementById('keys');
  const visionEl = document.getElementById('vision');
  const minotaurEl = document.getElementById('minotaur');

  const sizeVal = document.getElementById('sizeVal');
  const timeVal = document.getElementById('timeVal');
  const shiftVal = document.getElementById('shiftVal');
  const shiftChanceVal = document.getElementById('shiftChanceVal');
  const keysVal = document.getElementById('keysVal');
  const visionVal = document.getElementById('visionVal');

  const playBtn = document.getElementById('playBtn');
  const instructionsBtn = document.getElementById('instructionsBtn');
  const instructionsModal = document.getElementById('instructionsModal');
  const closeInstr = document.getElementById('closeInstr');

  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const timerPill = document.getElementById('timerPill');
  const keysPill = document.getElementById('keysPill');
  const modePill = document.getElementById('modePill');
  const statusPill = document.getElementById('statusPill');

  const menuBtn = document.getElementById('menuBtn');
  const restartBtn = document.getElementById('restartBtn');

  const instructionsToggle = document.getElementById('instructionsBtn');

  const presetEasy = document.getElementById('presetEasy');
  const presetMedium = document.getElementById('presetMedium');
  const presetHard = document.getElementById('presetHard');

  const gameOverModal = document.getElementById('gameOverModal');
  const gameOverTitle = document.getElementById('gameOverTitle');
  const gameOverText = document.getElementById('gameOverText');
  const playAgain = document.getElementById('playAgain');
  const backToMenu = document.getElementById('backToMenu');

  // ---------- Persistence ----------
  const STORAGE_KEY = 'labyrinth_settings_v1';
  const defaultSettings = {
    size: 15, time: 45, shiftInterval: 5, shiftChance: 0.2, keysNeeded: 0, visionRadius: 0, minotaur: false
  };

  function loadSettings(){
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if(raw) return JSON.parse(raw);
    } catch(e){}
    return defaultSettings;
  }
  function saveSettings(s){
    try { localStorage.setItem(STORAGE_KEY, JSON.stringify(s)); } catch(e){}
  }

  // ---------- Set UI from settings ----------
  function applySettingsToUI(s){
    sizeEl.value = s.size; sizeVal.textContent = s.size;
    timeEl.value = s.time; timeVal.textContent = s.time;
    shiftEl.value = s.shiftInterval; shiftVal.textContent = s.shiftInterval;
    shiftChanceEl.value = Math.round((s.shiftChance||0) * 100); shiftChanceVal.textContent = Math.round((s.shiftChance||0) * 100);
    keysEl.value = s.keysNeeded; keysVal.textContent = s.keysNeeded;
    visionEl.value = s.visionRadius; visionVal.textContent = s.visionRadius;
    minotaurEl.checked = !!s.minotaur;
  }

  function readSettingsFromUI(){
    return {
      size: clampInt(parseInt(sizeEl.value), 5, 30),
      time: clampInt(parseInt(timeEl.value), 5, 180),
      shiftInterval: Number(shiftEl.value),
      shiftChance: Number(shiftChanceEl.value)/100,
      keysNeeded: clampInt(parseInt(keysEl.value), 0, 6),
      visionRadius: clampInt(parseInt(visionEl.value), 0, 12),
      minotaur: !!minotaurEl.checked
    };
  }

  // ---------- helpers ----------
  function clampInt(v,min,max){ return Math.max(min, Math.min(max, Math.round(v))); }

  // sync UI displays
  [sizeEl, timeEl, shiftEl, shiftChanceEl, keysEl, visionEl].forEach(el=>{
    el.addEventListener('input', ()=>{
      sizeVal.textContent = sizeEl.value;
      timeVal.textContent = timeEl.value;
      shiftVal.textContent = shiftEl.value;
      shiftChanceVal.textContent = shiftChanceEl.value;
      keysVal.textContent = keysEl.value;
      visionVal.textContent = visionEl.value;
    });
  });

  // presets
  presetEasy.addEventListener('click', ()=>{ applySettingsToUI({size:10,time:60,shiftInterval:0,shiftChance:0,keysNeeded:0,visionRadius:0,minotaur:false}); saveSettings(readSettingsFromUI()); });
  presetMedium.addEventListener('click', ()=>{ applySettingsToUI({size:15,time:45,shiftInterval:5,shiftChance:0.2,keysNeeded:0,visionRadius:6,minotaur:false}); saveSettings(readSettingsFromUI()); });
  presetHard.addEventListener('click', ()=>{ applySettingsToUI({size:20,time:30,shiftInterval:3,shiftChance:1,keysNeeded:3,visionRadius:5,minotaur:false}); saveSettings(readSettingsFromUI()); });

  // load stored settings
  const initialSettings = loadSettings();
  applySettingsToUI(initialSettings);

  // ---------- Maze engine (modular) ----------
  let maze = null, cols = 0, rows = 0, cellSize = 0, originX = 0, originY = 0;
  let player = null, exitCell = null, keys = [], keysCollected = 0;
  let timer = 0, timerInterval = null;
  let shiftIntervalId = null;
  let minotaur = null, minotaurIntervalId = null;
  let running = false;
  let currentSettings = null;

  // Maze generation â€” recursive backtracker
  function makeMaze(n){
    cols = n; rows = n;
    const grid = new Array(cols);
    for(let x=0;x<cols;x++){
      grid[x] = new Array(rows);
      for(let y=0;y<rows;y++){
        grid[x][y] = { x,y, walls:[true,true,true,true], visited:false };
      }
    }

    function neighbors(c){
      const list = [];
      const {x,y} = c;
      if(y>0) list.push(grid[x][y-1]);       // N
      if(x<cols-1) list.push(grid[x+1][y]);  // E
      if(y<rows-1) list.push(grid[x][y+1]);  // S
      if(x>0) list.push(grid[x-1][y]);       // W
      return list.filter(n=>!n.visited);
    }
    function removeWall(a,b){
      const dx = b.x - a.x, dy = b.y - a.y;
      if(dx === 1){ a.walls[1]=false; b.walls[3]=false; }
      else if(dx === -1){ a.walls[3]=false; b.walls[1]=false; }
      else if(dy === 1){ a.walls[2]=false; b.walls[0]=false; }
      else if(dy === -1){ a.walls[0]=false; b.walls[2]=false; }
    }
    const stack = [];
    const start = grid[0][0];
    start.visited = true;
    stack.push(start);
    while(stack.length){
      const cur = stack[stack.length-1];
      const nlist = neighbors(cur);
      if(nlist.length){
        const next = nlist[Math.floor(Math.random()*nlist.length)];
        removeWall(cur,next);
        next.visited = true;
        stack.push(next);
      } else stack.pop();
    }
    // reset visited flags
    for(let x=0;x<cols;x++) for(let y=0;y<rows;y++) grid[x][y].visited = false;
    return grid;
  }

  // drawing
  function draw(){
    // compute layout
    ctx.clearRect(0,0,canvas.width,canvas.height);
    const pad = 8;
    const area = Math.min(canvas.width, canvas.height) - pad*2;
    cellSize = Math.floor(area / Math.max(cols, rows));
    originX = Math.floor((canvas.width - cols*cellSize)/2);
    originY = Math.floor((canvas.height - rows*cellSize)/2);

    // background floor
    ctx.fillStyle = '#001b20';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // walls
    ctx.lineWidth = Math.max(2, Math.floor(cellSize*0.08));
    ctx.strokeStyle = '#08333a';
    for(let x=0;x<cols;x++){
      for(let y=0;y<rows;y++){
        const cell = maze[x][y];
        const px = originX + x*cellSize;
        const py = originY + y*cellSize;

        ctx.fillStyle = '#02252b';
        ctx.fillRect(px+1, py+1, cellSize-2, cellSize-2);

        ctx.beginPath();
        if(cell.walls[0]){ ctx.moveTo(px,py); ctx.lineTo(px+cellSize,py); } // N
        if(cell.walls[1]){ ctx.moveTo(px+cellSize,py); ctx.lineTo(px+cellSize,py+cellSize); } // E
        if(cell.walls[2]){ ctx.moveTo(px+cellSize,py+cellSize); ctx.lineTo(px,py+cellSize); } // S
        if(cell.walls[3]){ ctx.moveTo(px,py+cellSize); ctx.lineTo(px,py); } // W
        ctx.stroke();
      }
    }

    // keys
    keys.forEach(k=>{
      const cx = originX + k.x*cellSize + cellSize/2;
      const cy = originY + k.y*cellSize + cellSize/2;
      ctx.fillStyle = '#ffd166';
      ctx.beginPath();
      ctx.arc(cx,cy, Math.max(4, cellSize*0.14), 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = '#b37f00';
      ctx.fillRect(cx-2, cy-1, 4, 2);
    });

    // exit
    if(exitCell){
      const px = originX + exitCell.x*cellSize;
      const py = originY + exitCell.y*cellSize;
      ctx.fillStyle = '#34d399';
      ctx.fillRect(px + cellSize*0.2, py + cellSize*0.2, cellSize*0.6, cellSize*0.6);
    }

    // player
    const ppx = originX + player.x*cellSize + cellSize*0.12;
    const ppy = originY + player.y*cellSize + cellSize*0.12;
    ctx.fillStyle = '#60a5fa';
    ctx.fillRect(ppx,ppy,cellSize*0.76, cellSize*0.76);

    // minotaur
    if(minotaur){
      const mpx = originX + minotaur.x*cellSize + cellSize*0.2;
      const mpy = originY + minotaur.y*cellSize + cellSize*0.2;
      ctx.fillStyle = '#ff6b6b';
      ctx.fillRect(mpx, mpy, cellSize*0.6, cellSize*0.6);
    }

    // fog of war (vision radius)
    if(currentSettings.visionRadius > 0){
      const vis = currentSettings.visionRadius;
      const cx = originX + (player.x+0.5)*cellSize;
      const cy = originY + (player.y+0.5)*cellSize;
      const radiusPx = Math.max(1, vis * cellSize);
      const grad = ctx.createRadialGradient(cx,cy, radiusPx*0.2, cx,cy, radiusPx);
      grad.addColorStop(0, 'rgba(0,0,0,0)');
      grad.addColorStop(0.6, 'rgba(0,0,0,0.45)');
      grad.addColorStop(1, 'rgba(0,0,0,0.95)');
      ctx.fillStyle = grad;
      ctx.fillRect(0,0,canvas.width,canvas.height);
    }

    // status pills
    timerPill.textContent = `Time: ${formatTime(timer)}`;
    keysPill.textContent = `Keys: ${keysCollected} / ${currentSettings.keysNeeded}`;
  }

  // ---------- gameplay helpers ----------
  function formatTime(s){
    const mm = Math.floor(s/60);
    const ss = s % 60;
    return `${mm}:${ss.toString().padStart(2,'0')}`;
  }

  function canMove(cell, dir){
    // 0=N,1=E,2=S,3=W
    return !maze[cell.x][cell.y].walls[dir];
  }

  function movePlayer(dir){
    if(!running) return;
    if(!canMove(player,dir)) return;
    if(dir===0) player.y -=1;
    if(dir===1) player.x +=1;
    if(dir===2) player.y +=1;
    if(dir===3) player.x -=1;
    onPlayerMove();
  }

  function onPlayerMove(){
    // collect keys
    for(let i=keys.length-1;i>=0;i--){
      if(keys[i].x===player.x && keys[i].y===player.y){
        keys.splice(i,1);
        keysCollected++;
        statusPill.textContent = 'Picked up a key!';
      }
    }
    // check exit
    if(exitCell && player.x===exitCell.x && player.y===exitCell.y){
      if(keysCollected >= currentSettings.keysNeeded){
        win();
      } else {
        statusPill.textContent = `Door locked â€” need ${currentSettings.keysNeeded - keysCollected} more.`;
      }
    }
    // minotaur collision
    if(minotaur && player.x===minotaur.x && player.y===minotaur.y){
      lose('Caught by the Minotaur!');
    }
    draw();
  }

  function placeKeys(n){
    keys = [];
    let attempts = 0;
    while(keys.length < n && attempts < 3000){
      attempts++;
      const x = Math.floor(Math.random()*cols);
      const y = Math.floor(Math.random()*rows);
      if((x===player.x && y===player.y) || (exitCell && x===exitCell.x && y===exitCell.y)) continue;
      if(keys.some(k=>k.x===x && k.y===y)) continue;
      keys.push({x,y});
    }
    keysCollected = 0;
  }

  function placeExit(){
    exitCell = { x: cols-1, y: rows-1 };
  }

  // ---------- timers & shifting ----------
  function startTimer(){
    timer = currentSettings.time;
    if(timerInterval) clearInterval(timerInterval);
    timerInterval = setInterval(()=>{
      timer--;
      if(timer <= 0){
        clearInterval(timerInterval);
        lose('Time ran out!');
      }
      draw();
    }, 1000);
  }
  function stopTimer(){ if(timerInterval){ clearInterval(timerInterval); timerInterval = null; } }

  function startShifting(){
    if(shiftIntervalId) clearInterval(shiftIntervalId);
    if(currentSettings.shiftInterval <= 0) return;
    shiftIntervalId = setInterval(()=>{
      if(Math.random() > currentSettings.shiftChance) return;
      // choose random cell and neighbor direction
      const x = Math.floor(Math.random()*cols);
      const y = Math.floor(Math.random()*rows);
      const dir = Math.floor(Math.random()*4);
      const nx = x + (dir===1?1:dir===3?-1:0);
      const ny = y + (dir===2?1:dir===0?-1:0);
      if(nx<0||nx>=cols||ny<0||ny>=rows) return;
      // toggle wall -- simple approach (may produce unreachable pockets for tension)
      const a = maze[x][y], b = maze[nx][ny];
      a.walls[dir] = !a.walls[dir];
      b.walls[(dir+2)%4] = !b.walls[(dir+2)%4];
      statusPill.textContent = 'Walls shifted!';
      draw();
    }, Math.max(200, currentSettings.shiftInterval*1000));
  }
  function stopShifting(){ if(shiftIntervalId){ clearInterval(shiftIntervalId); shiftIntervalId=null; } }

  // ---------- Minotaur BFS ----------
  function spawnMinotaur(){
    minotaur = { x: Math.max(0, cols-1), y: 0 }; // corner
  }
  function stepMinotaur(){
    if(!minotaur) return;
    // BFS
    const start = `${minotaur.x},${minotaur.y}`;
    const goal = `${player.x},${player.y}`;
    const queue = [{x:minotaur.x,y:minotaur.y,path:[]}];
    const seen = new Set([start]);
    while(queue.length){
      const cur = queue.shift();
      if(cur.x === player.x && cur.y === player.y){
        if(cur.path.length >= 1){
          const nxt = cur.path[0];
          minotaur.x = nxt.x; minotaur.y = nxt.y;
        }
        break;
      }
      const c = maze[cur.x][cur.y];
      const dirs = [
        {dx:0,dy:-1,dir:0},
        {dx:1,dy:0,dir:1},
        {dx:0,dy:1,dir:2},
        {dx:-1,dy:0,dir:3}
      ];
      for(const d of dirs){
        if(c.walls[d.dir]) continue;
        const nx = cur.x + d.dx, ny = cur.y + d.dy;
        if(nx<0||nx>=cols||ny<0||ny>=rows) continue;
        const key = `${nx},${ny}`;
        if(seen.has(key)) continue;
        seen.add(key);
        queue.push({x:nx,y:ny,path: cur.path.concat([{x:nx,y:ny}])});
      }
    }
    // collision
    if(minotaur.x === player.x && minotaur.y === player.y){
      lose('Caught by the Minotaur!');
    }
  }

  // ---------- Start / stop / reset / win / lose ----------
  function startGameFromUI(){
    // save settings
    const s = readSettingsFromUI();
    saveSettings(s);
    startGame(s);
  }

  function startGame(settings){
    stopGame();
    currentSettings = Object.assign({}, settings);
    // build maze, player, exit, keys, etc.
    maze = makeMaze(currentSettings.size);
    player = { x: 0, y: 0 };
    placeExit();
    placeKeys(currentSettings.keysNeeded);
    if(currentSettings.minotaur){
      spawnMinotaur();
    } else minotaur = null;
    // UI labels
    modePill.textContent = `Mode: ${currentSettings.size}Ã—${currentSettings.size}`;
    statusPill.textContent = 'Go!';
    keysPill.textContent = `Keys: ${keysCollected} / ${currentSettings.keysNeeded}`;
    // timers & shifting
    running = true;
    startTimer();
    startShifting();
    if(currentSettings.minotaur){
      if(minotaurIntervalId) clearInterval(minotaurIntervalId);
      minotaurIntervalId = setInterval(()=>{ stepMinotaur(); draw(); }, 400);
    }
    draw();
    canvas.focus();
  }

  function stopGame(){
    running = false;
    stopTimer();
    stopShifting();
    if(minotaurIntervalId){ clearInterval(minotaurIntervalId); minotaurIntervalId=null; }
  }

  function restartGame(){
    if(!currentSettings) return;
    startGame(currentSettings);
  }

  function win(){
    stopGame();
    showGameOver(true, 'You escaped! ðŸŽ‰');
  }

  function lose(msg){
    stopGame();
    showGameOver(false, msg || 'You lost.');
  }

  // ---------- UI event bindings ----------
  playBtn.addEventListener('click', startGameFromUI);
  instructionsBtn.addEventListener('click', ()=>{ instructionsModal.style.display = 'flex'; });
  closeInstr.addEventListener('click', ()=>{ instructionsModal.style.display='none'; });
  menuBtn.addEventListener('click', ()=>{ // back to menu (stop game)
    stopGame();
    statusPill.textContent = 'Main menu';
  });
  restartBtn.addEventListener('click', ()=>{ restartGame(); });
  playAgain.addEventListener('click', ()=>{ gameOverModal.style.display='none'; restartGame(); });
  backToMenu.addEventListener('click', ()=>{ gameOverModal.style.display='none'; stopGame(); statusPill.textContent='Main menu'; });

  // play modal from menu
  function showGameOver(won, text){
    gameOverTitle.textContent = won ? 'You Win!' : 'Game Over';
    gameOverText.textContent = text;
    gameOverModal.style.display = 'flex';
  }

  // presets and local save
  // initial settings show
  const stored = loadSettings();
  applySettingsToUI(stored);

  // keyboard controls
  window.addEventListener('keydown', (e)=>{
    if(!running) return;
    const k = e.key;
    if(['ArrowUp','w','W'].includes(k)){ e.preventDefault(); movePlayer(0); }
    else if(['ArrowRight','d','D'].includes(k)){ e.preventDefault(); movePlayer(1); }
    else if(['ArrowDown','s','S'].includes(k)){ e.preventDefault(); movePlayer(2); }
    else if(['ArrowLeft','a','A'].includes(k)){ e.preventDefault(); movePlayer(3); }
    else if(k === ' '){ e.preventDefault(); // interact/open door if at exit
      if(exitCell && player.x===exitCell.x && player.y===exitCell.y){
        if(keysCollected >= currentSettings.keysNeeded) win();
        else statusPill.textContent = `Door locked â€” need ${currentSettings.keysNeeded - keysCollected}`;
      }
    }
  });

  canvas.addEventListener('click', ()=> canvas.focus());

  // draw a helpful initial screen
  function drawInitial(){
    ctx.fillStyle = '#00121a';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = '#6ee7b7';
    ctx.font = '24px Inter, Arial';
    ctx.fillText('Choose settings and press Play', 22, 40);
  }
  drawInitial();

  // expose startGame to console for advanced users
  window.startGame = startGame;

  // set UI displayed values to current
  sizeVal.textContent = sizeEl.value;
  timeVal.textContent = timeEl.value;
  shiftVal.textContent = shiftEl.value;
  shiftChanceVal.textContent = shiftChanceEl.value;
  keysVal.textContent = keysEl.value;
  visionVal.textContent = visionEl.value;

  // small helper: when settings change, update stored immediately
  [sizeEl,timeEl,shiftEl,shiftChanceEl,keysEl,visionEl,minotaurEl].forEach(el=>{
    el.addEventListener('change', ()=> saveSettings(readSettingsFromUI()));
  });

})();
</script>
</body>
</html>
