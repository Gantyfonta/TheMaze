<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Labyrinth Challenge</title>
<style>
  :root{
    --bg:#07121a; --panel:#0a1c2b; --accent:#06b6d4; --muted:#9aa8b6; --ok:#34d399; --warn:#ffb454; --danger:#ff6b6b;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;background:radial-gradient(1200px 800px at 30% 10%, #0a1a26, #05131e 50%, #03101a);color:#e6f0fb}
  button{cursor:pointer}

  /* Screens */
  .screen{position:fixed;inset:0;display:none;align-items:center;justify-content:center;padding:24px}
  .screen.active{display:flex}
  .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.06);border-radius:14px;box-shadow:0 20px 60px rgba(2,6,23,0.65);padding:22px;max-width:720px;width:min(92%, 720px)}
  .title{font-size:36px;margin:0 0 6px 0}
  .subtitle{color:var(--muted);margin:0 0 16px 0}
  .row{display:flex;gap:10px;flex-wrap:wrap}
  .btn{background:var(--accent);color:#04121b;border:0;border-radius:10px;padding:12px 16px;font-weight:800}
  .ghost{background:transparent;border:1px solid rgba(255,255,255,0.08);color:#d4e2ef}
  .danger{background:var(--danger);color:#1a0202}
  .ok{background:var(--ok);color:#001912}
  .muted{color:var(--muted)}

  /* Settings */
  .field{margin:10px 0}
  .field > div{display:flex;justify-content:space-between;align-items:center}
  .value{font-weight:800;color:#bfefff;margin-left:10px}
  input[type=range]{width:100%}
  .toggle{display:flex;align-items:center;gap:8px}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  @media (max-width:680px){ .grid{grid-template-columns:1fr} }

  /* Game */
  #gameHUD{position:fixed;top:10px;left:10px;right:10px;display:flex;justify-content:space-between;gap:8px;pointer-events:none}
  .pill{pointer-events:auto;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.08);padding:8px 12px;border-radius:999px;font-weight:800}
  #hudRight{display:flex;gap:8px}
  #canvas{display:block;margin:auto;border-radius:12px;background:#00121a;max-width:980px;width:min(94vw, 980px);height:auto;aspect-ratio:1/1}
  #gameWrap{position:fixed;inset:0;display:none;align-items:center;justify-content:center;padding:12px}
  #gameWrap.active{display:flex}

  /* Game Over */
  .center{text-align:center}
</style>
</head>
<body>

<!-- ================ TITLE ================ -->
<section id="screenTitle" class="screen active" aria-label="Title screen">
  <div class="card center">
    <h1 class="title">Labyrinth Challenge</h1>
    <p class="subtitle">Race the clock, collect keys, dodge the Minotaur.</p>
    <div class="row" style="justify-content:center">
      <button id="btnPlayFromTitle" class="btn">Play</button>
      <button id="btnSettingsFromTitle" class="btn ghost">Settings</button>
      <button id="btnInstructions" class="btn ghost">Instructions</button>
    </div>
    <p class="muted" style="margin-top:14px">Tip: You can save your favorite setup as your browser settings ‚Äî no coding needed.</p>
  </div>
</section>

<!-- ================ SETTINGS ================ -->
<section id="screenSettings" class="screen" aria-label="Settings">
  <div class="card">
    <h2 style="margin:0 0 8px 0">Settings</h2>
    <div class="grid">
      <div class="field">
        <div><span>Maze Size</span><span class="value" id="valSize">15</span></div>
        <input id="ctlSize" type="range" min="5" max="30" step="1" value="15">
      </div>
      <div class="field">
        <div><span>Time Limit (s)</span><span class="value" id="valTime">45</span></div>
        <input id="ctlTime" type="range" min="5" max="180" step="1" value="45">
      </div>
      <div class="field">
        <div><span>Wall Shift Interval (s, 0 = off)</span><span class="value" id="valShiftI">5</span></div>
        <input id="ctlShiftI" type="range" min="0" max="10" step="0.5" value="5">
      </div>
      <div class="field">
        <div><span>Shift Chance (%)</span><span class="value" id="valShiftC">20</span></div>
        <input id="ctlShiftC" type="range" min="0" max="100" step="5" value="20">
      </div>
      <div class="field">
        <div><span>Keys Required</span><span class="value" id="valKeys">0</span></div>
        <input id="ctlKeys" type="range" min="0" max="6" step="1" value="0">
      </div>
      <div class="field">
        <div><span>Vision Radius (0 = full sight)</span><span class="value" id="valVision">0</span></div>
        <input id="ctlVision" type="range" min="0" max="12" step="1" value="0">
      </div>
      <div class="field toggle" style="grid-column:1/-1">
        <input id="ctlMinotaur" type="checkbox">
        <label for="ctlMinotaur">Enable Minotaur (BFS chase)</label>
      </div>
    </div>
    <div class="row" style="margin-top:12px">
      <button id="btnStart" class="btn">Play</button>
      <button id="btnBackTitle" class="btn ghost">Back</button>
      <button id="btnPresetEasy" class="btn ghost">Easy</button>
      <button id="btnPresetMedium" class="btn ghost">Medium</button>
      <button id="btnPresetHard" class="btn danger">Hard</button>
    </div>
  </div>
</section>

<!-- ================ GAME ================ -->
<section id="gameWrap" aria-label="Game">
  <div id="gameHUD">
    <div class="pill" id="hudMode">Mode: ‚Äî</div>
    <div id="hudRight">
      <div class="pill" id="hudTimer">Time: ‚Äî</div>
      <div class="pill" id="hudKeys">Keys: 0 / 0</div>
      <div class="pill" id="hudStatus">Status: ‚Äî</div>
      <button id="btnRestart" class="pill ghost">Restart</button>
      <button id="btnMainMenu" class="pill ghost">Main Menu</button>
    </div>
  </div>
  <canvas id="canvas" width="900" height="900" tabindex="0" aria-label="Maze canvas"></canvas>
</section>

<!-- ================ GAME OVER ================ -->
<section id="screenOver" class="screen" aria-label="Game over">
  <div class="card center">
    <h2 id="overTitle" style="margin:0 0 8px 0">Game Over</h2>
    <p id="overText" class="muted" style="margin:0 0 8px 0">You lost.</p>
    <div class="row" style="justify-content:center">
      <button id="btnAgain" class="btn ok">Play Again</button>
      <button id="btnOverMenu" class="btn ghost">Main Menu</button>
      <button id="btnOverSettings" class="btn ghost">Settings</button>
    </div>
  </div>
</section>

<!-- ================ INSTRUCTIONS (modal-ish) ================ -->
<section id="screenInstr" class="screen" aria-label="Instructions">
  <div class="card">
    <h2 style="margin:0 0 8px 0">How to play</h2>
    <ul class="muted">
      <li>Use arrow keys or WASD to move.</li>
      <li>Collect the required keys and reach the green exit square before the timer hits 0.</li>
      <li>Walls may shift based on your settings; shifts never permanently block your path.</li>
      <li>If Minotaur is enabled, it chases you using BFS. Don‚Äôt let it touch you!</li>
      <li>Vision radius > 0 enables ‚Äúfog of war‚Äù.</li>
    </ul>
    <div class="row">
      <button id="btnInstrBack" class="btn">Back</button>
    </div>
  </div>
</section>

<script>
(() => {
  // ---------- Screen helpers ----------
  const screens = {
    title: document.getElementById('screenTitle'),
    settings: document.getElementById('screenSettings'),
    game: document.getElementById('gameWrap'),
    over: document.getElementById('screenOver'),
    instr: document.getElementById('screenInstr'),
  };
  function showScreen(name){
    Object.values(screens).forEach(el=>el.classList.remove('active'));
    screens[name].classList.add('active');
  }

  // ---------- Settings state ----------
  const SKEY = 'labyrinth_settings_fullscreen_v1';
  const defaults = { size:15, time:45, shiftInterval:5, shiftChance:0.2, keysNeeded:0, visionRadius:0, minotaur:false };
  function loadSettings(){ try{ const r = localStorage.getItem(SKEY); if(r) return JSON.parse(r); }catch(e){} return {...defaults}; }
  function saveSettings(s){ try{ localStorage.setItem(SKEY, JSON.stringify(s)); }catch(e){} }
  let currentSettings = loadSettings();

  // Controls
  const ctl = {
    size: document.getElementById('ctlSize'),
    time: document.getElementById('ctlTime'),
    shiftI: document.getElementById('ctlShiftI'),
    shiftC: document.getElementById('ctlShiftC'),
    keys: document.getElementById('ctlKeys'),
    vision: document.getElementById('ctlVision'),
    mino: document.getElementById('ctlMinotaur'),
    vSize: document.getElementById('valSize'),
    vTime: document.getElementById('valTime'),
    vShiftI: document.getElementById('valShiftI'),
    vShiftC: document.getElementById('valShiftC'),
    vKeys: document.getElementById('valKeys'),
    vVision: document.getElementById('valVision'),
  };
  function applyToUI(s){
    ctl.size.value = s.size; ctl.vSize.textContent = s.size;
    ctl.time.value = s.time; ctl.vTime.textContent = s.time;
    ctl.shiftI.value = s.shiftInterval; ctl.vShiftI.textContent = s.shiftInterval;
    ctl.shiftC.value = Math.round((s.shiftChance||0)*100); ctl.vShiftC.textContent = ctl.shiftC.value;
    ctl.keys.value = s.keysNeeded; ctl.vKeys.textContent = s.keysNeeded;
    ctl.vision.value = s.visionRadius; ctl.vVision.textContent = s.visionRadius;
    ctl.mino.checked = !!s.minotaur;
  }
  function readFromUI(){
    currentSettings = {
      size: clamp(parseInt(ctl.size.value), 5, 30),
      time: clamp(parseInt(ctl.time.value), 5, 180),
      shiftInterval: Number(ctl.shiftI.value),
      shiftChance: Number(ctl.shiftC.value)/100,
      keysNeeded: clamp(parseInt(ctl.keys.value), 0, 6),
      visionRadius: clamp(parseInt(ctl.vision.value), 0, 12),
      minotaur: !!ctl.mino.checked
    };
    saveSettings(currentSettings);
  }
  function clamp(v,lo,hi){ return Math.max(lo, Math.min(hi, v)); }
  ['size','time','shiftI','shiftC','keys','vision'].forEach(k=> ctl[k].addEventListener('input', ()=>{ readFromUI(); applyToUI(currentSettings); }));
  ctl.mino.addEventListener('change', ()=>{ readFromUI(); });

  // Presets
  document.getElementById('btnPresetEasy').onclick = ()=>{ currentSettings={size:10,time:60,shiftInterval:0,shiftChance:0,keysNeeded:0,visionRadius:0,minotaur:false}; applyToUI(currentSettings); saveSettings(currentSettings); };
  document.getElementById('btnPresetMedium').onclick = ()=>{ currentSettings={size:15,time:45,shiftInterval:5,shiftChance:0.2,keysNeeded:0,visionRadius:6,minotaur:false}; applyToUI(currentSettings); saveSettings(currentSettings); };
  document.getElementById('btnPresetHard').onclick = ()=>{ currentSettings={size:20,time:30,shiftInterval:3,shiftChance:1,keysNeeded:3,visionRadius:5,minotaur:true}; applyToUI(currentSettings); saveSettings(currentSettings); };

  applyToUI(currentSettings);

  // ---------- Title / Settings / Instructions navigation ----------
  document.getElementById('btnPlayFromTitle').onclick = ()=> showScreen('settings');
  document.getElementById('btnSettingsFromTitle').onclick = ()=> showScreen('settings');
  document.getElementById('btnInstructions').onclick = ()=> showScreen('instr');
  document.getElementById('btnInstrBack').onclick = ()=> showScreen('title');
  document.getElementById('btnBackTitle').onclick = ()=> showScreen('title');
  document.getElementById('btnStart').onclick = ()=>{ readFromUI(); startGame(currentSettings); };

  // ---------- Game elements ----------
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const hud = {
    mode: document.getElementById('hudMode'),
    timer: document.getElementById('hudTimer'),
    keys: document.getElementById('hudKeys'),
    status: document.getElementById('hudStatus'),
  };
  document.getElementById('btnMainMenu').onclick = ()=>{ stopGame(); showScreen('title'); };
  document.getElementById('btnRestart').onclick = ()=>{ if(currentSettings) startGame(currentSettings); };
  document.getElementById('btnOverMenu').onclick = ()=>{ showScreen('title'); };
  document.getElementById('btnOverSettings').onclick = ()=>{ showScreen('settings'); };
  document.getElementById('btnAgain').onclick = ()=>{ showScreen('game'); startGame(currentSettings); };

  // ---------- Game state ----------
  let maze, cols, rows, cellSize, originX, originY;
  let player, exitCell, keySpots = [], keysCollected = 0;
  let timer = 0, timerInterval = null, running = false;
  let shiftIntervalId = null;
  let minotaur = null, minoIntervalId = null;
  let animId = null;

  function startGame(s){
    stopGame();
    showScreen('game');
    // Build maze
    maze = buildMaze(s.size);
    cols = rows = s.size;
    player = {x:0,y:0,lastDx:0,lastDy:0};
    exitCell = {x:cols-1, y:rows-1};
    placeKeys(s.keysNeeded);
    keysCollected = 0;
    if(s.minotaur) minotaur = {x:cols-1, y:0}; else minotaur = null;

    hud.mode.textContent = `Mode: ${s.size}√ó${s.size}`;
    hud.status.textContent = 'Go!';
    hud.keys.textContent = `Keys: ${keysCollected} / ${s.keysNeeded}`;

    // Timers
    timer = s.time;
    timerInterval = setInterval(()=>{ timer--; if(timer<=0){ lose('Time ran out!'); } }, 1000);

    // Shifting
    if(s.shiftInterval>0){
      shiftIntervalId = setInterval(()=> tryShift(s), Math.max(120, s.shiftInterval*1000));
    }

    // Minotaur
    if(s.minotaur){
      minoIntervalId = setInterval(()=>{ stepMinotaur(); draw(); }, 420);
    }

    running = true;
    animId = requestAnimationFrame(draw);
    canvas.focus();
  }

  function stopGame(){
    running = false;
    if(timerInterval){ clearInterval(timerInterval); timerInterval=null; }
    if(shiftIntervalId){ clearInterval(shiftIntervalId); shiftIntervalId=null; }
    if(minoIntervalId){ clearInterval(minoIntervalId); minoIntervalId=null; }
    if(animId){ cancelAnimationFrame(animId); animId=null; }
  }

  function win(){
    stopGame();
    document.getElementById('overTitle').textContent = 'You Win!';
    document.getElementById('overText').textContent = 'You escaped the labyrinth. üéâ';
    showScreen('over');
  }
  function lose(msg){
    stopGame();
    document.getElementById('overTitle').textContent = 'Game Over';
    document.getElementById('overText').textContent = msg||'You lost.';
    showScreen('over');
  }

  // ---------- Maze generation (recursive backtracker) ----------
  function buildMaze(n){
    const grid = Array.from({length:n}, (_,x)=> Array.from({length:n}, (_,y)=>({x,y,walls:[true,true,true,true],visited:false})));
    function carve(a,b){
      const dx = b.x - a.x, dy = b.y - a.y;
      if(dx===1){ a.walls[1]=false; b.walls[3]=false; }
      else if(dx===-1){ a.walls[3]=false; b.walls[1]=false; }
      else if(dy===1){ a.walls[2]=false; b.walls[0]=false; }
      else if(dy===-1){ a.walls[0]=false; b.walls[2]=false; }
    }
    function unvisitedNeighbors(c){
      const out=[]; const {x,y}=c;
      if(y>0 && !grid[x][y-1].visited) out.push(grid[x][y-1]);
      if(x<n-1 && !grid[x+1][y].visited) out.push(grid[x+1][y]);
      if(y<n-1 && !grid[x][y+1].visited) out.push(grid[x][y+1]);
      if(x>0 && !grid[x-1][y].visited) out.push(grid[x-1][y]);
      return out;
    }
    const start = grid[0][0]; start.visited=true;
    const stack=[start];
    while(stack.length){
      const cur = stack[stack.length-1];
      const opts = unvisitedNeighbors(cur);
      if(opts.length){
        const next = opts[Math.floor(Math.random()*opts.length)];
        carve(cur,next);
        next.visited=true; stack.push(next);
      }else stack.pop();
    }
    for(let x=0;x<n;x++) for(let y=0;y<n;y++) grid[x][y].visited=false;
    return grid;
  }

  // ---------- Movement & interactions ----------
  window.addEventListener('keydown', (e)=>{
    if(!running) return;
    const k = e.key;
    if(['ArrowUp','w','W'].includes(k)){ e.preventDefault(); tryMove(0); }
    else if(['ArrowRight','d','D'].includes(k)){ e.preventDefault(); tryMove(1); }
    else if(['ArrowDown','s','S'].includes(k)){ e.preventDefault(); tryMove(2); }
    else if(['ArrowLeft','a','A'].includes(k)){ e.preventDefault(); tryMove(3); }
    else if(k===' '){ e.preventDefault(); // interact at exit
      if(player.x===exitCell.x && player.y===exitCell.y){
        if(keysCollected>=currentSettings.keysNeeded) win();
        else hud.status.textContent = `Door locked ‚Äî need ${currentSettings.keysNeeded - keysCollected}`;
      }
    }
  });

  function canGo(x,y,dir){
    const c = maze[x][y];
    return !c.walls[dir];
  }
  function tryMove(dir){
    let nx=player.x, ny=player.y;
    if(!canGo(player.x,player.y,dir)) return;
    if(dir===0) ny--;
    if(dir===1) nx++;
    if(dir===2) ny++;
    if(dir===3) nx--;
    player.x=nx; player.y=ny;
    player.lastDx = (dir===1?1:dir===3?-1:0);
    player.lastDy = (dir===2?1:dir===0?-1:0);
    afterMove();
  }
  function afterMove(){
    // key pickup
    for(let i=keySpots.length-1;i>=0;i--){
      if(keySpots[i].x===player.x && keySpots[i].y===player.y){
        keySpots.splice(i,1); keysCollected++;
        hud.status.textContent = 'Picked up a key!';
      }
    }
    // exit check
    if(player.x===exitCell.x && player.y===exitCell.y){
      if(keysCollected>=currentSettings.keysNeeded) win();
    }
    // minotaur collision
    if(minotaur && player.x===minotaur.x && player.y===minotaur.y) lose('Caught by the Minotaur!');
    // redraw
    draw();
  }

  function placeKeys(n){
    keySpots = [];
    let tries=0;
    while(keySpots.length<n && tries<3000){
      tries++;
      const x = Math.floor(Math.random()*cols), y = Math.floor(Math.random()*rows);
      if((x===0 && y===0) || (x===exitCell.x && y===exitCell.y)) continue;
      if(keySpots.some(k=>k.x===x && k.y===y)) continue;
      keySpots.push({x,y});
    }
  }

  // ---------- Wall shifting (connectivity-safe) ----------
  function isConnected(ax,ay,bx,by){
    const q=[{x:ax,y:ay}], seen=new Set([`${ax},${ay}`]);
    while(q.length){
      const c=q.shift();
      if(c.x===bx && c.y===by) return true;
      const cell = maze[c.x][c.y];
      const dirs=[{dx:0,dy:-1,dir:0},{dx:1,dy:0,dir:1},{dx:0,dy:1,dir:2},{dx:-1,dy:0,dir:3}];
      for(const d of dirs){
        if(cell.walls[d.dir]) continue;
        const nx=c.x+d.dx, ny=c.y+d.dy;
        if(nx<0||nx>=cols||ny<0||ny>=rows) continue;
        const key=`${nx},${ny}`; if(seen.has(key)) continue;
        seen.add(key); q.push({x:nx,y:ny});
      }
    }
    return false;
  }

  function tryShift(s){
    if(Math.random()>s.shiftChance) return; // no shift this tick
    const x = Math.floor(Math.random()*cols), y = Math.floor(Math.random()*rows), dir = Math.floor(Math.random()*4);
    const nx = x + (dir===1?1:dir===3?-1:0), ny = y + (dir===2?1:dir===0?-1:0);
    if(nx<0||nx>=cols||ny<0||ny>=rows) return;
    const a=maze[x][y], b=maze[nx][ny];
    const prevA=a.walls[dir], prevB=b.walls[(dir+2)%4];
    a.walls[dir]=!a.walls[dir]; b.walls[(dir+2)%4]=!b.walls[(dir+2)%4];

    // keep if: player->exit connected AND all remaining keys reachable from player
    let ok = isConnected(player.x,player.y, exitCell.x,exitCell.y);
    if(ok){
      for(const k of keySpots){
        if(!isConnected(player.x,player.y, k.x,k.y)){ ok=false; break; }
      }
    }
    if(!ok){ a.walls[dir]=prevA; b.walls[(dir+2)%4]=prevB; }
    else { hud.status.textContent = 'Walls shifted!'; }
    draw();
  }

  // ---------- Minotaur (BFS) ----------
  function stepMinotaur(){
    if(!minotaur) return;
    const q=[{x:minotaur.x,y:minotaur.y,path:[]}];
    const seen = new Set([`${minotaur.x},${minotaur.y}`]);
    while(q.length){
      const cur=q.shift();
      if(cur.x===player.x && cur.y===player.y){
        if(cur.path.length){ const n=cur.path[0]; minotaur.x=n.x; minotaur.y=n.y; }
        break;
      }
      const c = maze[cur.x][cur.y];
      const dirs=[{dx:0,dy:-1,dir:0},{dx:1,dy:0,dir:1},{dx:0,dy:1,dir:2},{dx:-1,dy:0,dir:3}];
      for(const d of dirs){
        if(c.walls[d.dir]) continue;
        const nx=cur.x+d.dx, ny=cur.y+d.dy;
        if(nx<0||nx>=cols||ny<0||ny>=rows) continue;
        const key=`${nx},${ny}`; if(seen.has(key)) continue;
        seen.add(key);
        q.push({x:nx,y:ny,path:cur.path.concat([{x:nx,y:ny}])});
      }
    }
    if(minotaur.x===player.x && minotaur.y===player.y) lose('Caught by the Minotaur!');
  }

  // ---------- Drawing ----------
  function draw(){
    if(!currentSettings) return;
    // layout
    const pad=10;
    const area = Math.min(canvas.width, canvas.height) - pad*2;
    cellSize = Math.floor(area / Math.max(cols, rows));
    originX = Math.floor((canvas.width - cols*cellSize)/2);
    originY = Math.floor((canvas.height - rows*cellSize)/2);

    // bg
    ctx.fillStyle='#00121a'; ctx.fillRect(0,0,canvas.width,canvas.height);

    // grid + walls
    ctx.lineWidth = Math.max(2, Math.floor(cellSize*0.08));
    for(let x=0;x<cols;x++){
      for(let y=0;y<rows;y++){
        const c = maze[x][y];
        const px=originX+x*cellSize, py=originY+y*cellSize;
        ctx.fillStyle='#02252b'; ctx.fillRect(px+1,py+1,cellSize-2,cellSize-2);
        ctx.strokeStyle='#08333a'; ctx.beginPath();
        if(c.walls[0]){ ctx.moveTo(px,py); ctx.lineTo(px+cellSize,py); }
        if(c.walls[1]){ ctx.moveTo(px+cellSize,py); ctx.lineTo(px+cellSize,py+cellSize); }
        if(c.walls[2]){ ctx.moveTo(px+cellSize,py+cellSize); ctx.lineTo(px,py+cellSize); }
        if(c.walls[3]){ ctx.moveTo(px,py+cellSize); ctx.lineTo(px,py); }
        ctx.stroke();
      }
    }

    // keys
    for(const k of keySpots){
      const cx = originX + k.x*cellSize + cellSize/2;
      const cy = originY + k.y*cellSize + cellSize/2;
      ctx.fillStyle='#ffd166'; ctx.beginPath(); ctx.arc(cx,cy, Math.max(4, cellSize*0.14), 0, Math.PI*2); ctx.fill();
      ctx.fillStyle='#b37f00'; ctx.fillRect(cx-2, cy-1, 4, 2);
    }

    // exit
    const ex = originX + exitCell.x*cellSize, ey = originY + exitCell.y*cellSize;
    ctx.fillStyle = '#34d399'; ctx.fillRect(ex + cellSize*0.2, ey + cellSize*0.2, cellSize*0.6, cellSize*0.6);

    // player (bobbing + eye)
    const bob = Math.sin((Date.now()%800)/800 * Math.PI*2) * (cellSize*0.04);
    const ppx = originX + player.x*cellSize + cellSize*0.12;
    const ppy = originY + player.y*cellSize + cellSize*0.12 + bob;
    roundRect(ctx, ppx, ppy, cellSize*0.76, cellSize*0.76, cellSize*0.16, true);
    // eye
    ctx.fillStyle='#021826';
    const eyeX = ppx + (cellSize*0.76)/2 + (player.lastDx||0) * (cellSize*0.12);
    const eyeY = ppy + (cellSize*0.76)/2 + (player.lastDy||0) * (cellSize*0.12);
    ctx.beginPath(); ctx.arc(eyeX, eyeY, Math.max(3, cellSize*0.06), 0, Math.PI*2); ctx.fill();

    // minotaur
    if(minotaur){
      const t=(Date.now()%1000)/1000, pulse=1+Math.sin(t*Math.PI*2)*0.06;
      const mx = originX + minotaur.x*cellSize + cellSize*0.2;
      const my = originY + minotaur.y*cellSize + cellSize*0.2;
      const w = cellSize*0.6*pulse, h=cellSize*0.6*pulse, offx=(cellSize*0.6-w)/2, offy=(cellSize*0.6-h)/2;
      const r=255, g=Math.floor(100+80*Math.abs(Math.sin(t*Math.PI*2))), b=110;
      ctx.fillStyle=`rgb(${r},${g},${b})`;
      roundRect(ctx, mx+offx, my+offy, w, h, cellSize*0.12, true);
    }

    // fog
    if(currentSettings.visionRadius>0){
      const vis=currentSettings.visionRadius;
      const cx = originX + (player.x+0.5)*cellSize;
      const cy = originY + (player.y+0.5)*cellSize;
      const r = Math.max(1, vis*cellSize);
      const g = ctx.createRadialGradient(cx,cy,r*0.15, cx,cy,r);
      g.addColorStop(0,'rgba(0,0,0,0)'); g.addColorStop(0.6,'rgba(0,0,0,0.45)'); g.addColorStop(1,'rgba(0,0,0,0.95)');
      ctx.fillStyle=g; ctx.fillRect(0,0,canvas.width,canvas.height);
    }

    // HUD
    hud.timer.textContent = `Time: ${fmtTime(timer)}`;
    hud.keys.textContent = `Keys: ${keysCollected} / ${currentSettings.keysNeeded}`;

    animId = requestAnimationFrame(draw);
  }

  function roundRect(ctx,x,y,w,h,r,fill){
    ctx.beginPath();
    ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath();
    if(fill) ctx.fillStyle='#60a5fa', ctx.fill();
  }

  function fmtTime(s){ const m=Math.floor(s/60), sec=s%60; return `${m}:${sec.toString().padStart(2,'0')}`; }

  // ---------- HUD timer refresher (separate from draw loop) ----------
  setInterval(()=>{ if(running) hud.timer.textContent = `Time: ${fmtTime(timer)}`; }, 250);

})();
</script>
</body>
</html>
